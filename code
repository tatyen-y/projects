import numpy as np
import pandas as pd
from tqdm import tqdm

def region_macro(region: str) -> str:
    if region in ('Г. Москва', 'Москва', 'Москва Город', 'Город Москва'):
        return 'MOS'
    elif region in ('Ленинградская Область', 'Ленинградская область'):
        return 'LEN'
    elif region in ('Московская Область', 'Московская область'):
        return 'OBL'
    elif region in ('Санкт-Петербург', 'Санкт-Петербург Город', 'Город Санкт-Петербург'):
        return 'SPB'
    elif region in ('Краснодарский Край', 'Краснодарский край'):
        return 'KRA'
    elif region in ('Амурская Область', 'Амурская область', 'Бурятия Республика', 'Забайкальский Край',
                    'Забайкальский Край', 'Приморский Край', 'Приморский край', 'Магаданская Область',
                    'Магаданская область', 'Камчатский Край', 'Камчатский край', 'Камчатка',
                    'Сахалинская область', 'Сахалинская Область', 'Сахалин', 'Хабаровский Край',
                    'Хабаровский край', 'Чукотский автономный округ', 'Чукотский АО', 'Чукотка',
                    'Саха /Якутия/ Республика', 'Якутия', 'Саха', 'Саха Республика', 'Саха республика'):
        return 'FAR'
    else:
        return 'RUS'

def get_analog_price(target_row, data, max_dist=5):
    try:
        idx = target_row.index[0]
        lat = target_row.at[idx, 'lat'] * np.pi / 180
        lon = target_row.at[idx, 'lon'] * np.pi / 180

        # Фильтрация данных: исключаем текущий объект из данных
        analog_filter = (data['ID'] != target_row.at[idx, 'ID'])
        analog_data = data[analog_filter].copy()

        analog_data['lat_rad'] = analog_data['lat'] * np.pi / 180
        analog_data['lon_rad'] = analog_data['lon'] * np.pi / 180
        analog_data['DISTANCE'] = np.arccos(np.sin(lat) * np.sin(analog_data['lat_rad']) +
                                            np.cos(lat) * np.cos(analog_data['lat_rad']) *
                                            np.cos(analog_data['lon_rad'] - lon)) * 6371

        analogs = analog_data[analog_data['DISTANCE'] <= max_dist].copy()
        
        if analogs.shape[0] == 0:
            return -1, 0, -1

        # Корректировка цен по времени
        try:
            analogs['price_corrected'] = analogs['quarter_price_m2'] * (1.02 ** (target_row.at[idx, 'Y+Q'] - analogs['Y+Q']))
        except Exception as e:
            print(f"Ошибка корректировки цен по времени для индекса {idx}: {e}")
            return None, None, None

        # Корректировка по типу стен
        try:
            walls = target_row.at[idx, 'wallMaterial.name']
            print(f"Стены для индекса {idx}: {walls}")  # Отладочное сообщение
            if walls in ['Монолитный', 'Кирпичный', 'Монолитно-кирпичный']:
                analogs['price_corrected'] *= (1 + 0.1 * (1 - analogs['wallMaterial.name'].isin(['Монолитный', 'Кирпичный', 'Монолитно-кирпичный'])))
            else:
                analogs['price_corrected'] /= (1 + 0.1 * analogs['wallMaterial.name'].isin(['Монолитный', 'Кирпичный', 'Монолитно-кирпичный']))
        except Exception as e:
            print(f"Ошибка корректировки по типу стен для индекса {idx}: {e}")
            return None, None, None
        
        # Корректировка по классу недвижимости
        try:
            property_class = target_row.at[idx, 'propertyClass.name']
            print(f"Класс недвижимости для индекса {idx}: {property_class}")  # Отладочное сообщение
            if property_class == 'Комфорт':
                analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
            elif property_class == 'Бизнес':
                analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
            else:
                analogs['price_corrected'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
        except Exception as e:
            print(f"Ошибка корректировки по классу недвижимости для индекса {idx}: {e}")
            return None, None, None
        
        # Корректировка по виду парковки
        try:
            parking_type = target_row.at[idx, 'parking_type']
            print(f"Вид парковки для индекса {idx}: {parking_type}")  # Отладочное сообщение
            if parking_type == 0 or parking_type == 1:  # наземная или многоуровневая наземная
                analogs['price_corrected'] /= (1 + 0.15 * (analogs['parking_type'] == 2))  # подземная
        except Exception as e:
            print(f"Ошибка корректировки по виду парковки для индекса {idx}: {e}")
            return None, None, None

        # Корректировка по макрорегиону
        try:
            obs_region_macro = target_row.at[idx, 'RegionMacro']
            analogs['RegionMacro'] = analogs['Region'].apply(region_macro)
            if obs_region_macro not in ['MOS', 'SPB']:
                if target_row.at[idx, 'propertyClass.name'] == 'Комфорт':
                    analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
                else:
                    analogs['price_corrected'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
        except Exception as e:
            print(f"Ошибка корректировки по макрорегиону для индекса {idx}: {e}")
            return None, None, None

        analogs = analogs.groupby('ID').mean()
        price_mean = analogs['price_corrected'].mean()
        analog_count = analogs.shape[0]
        readiness_mean = analogs['ReadinessCalc'].mean()
        
        return price_mean, analog_count, readiness_mean
    except Exception as e:
        print(f"Ошибка при обработке индекса {idx}: {e}")
        return None, None, None

# Применение функции к новому датасету
data = data[['Y+Q', 'propertyClass.name', 'wallMaterial.name', 'lat', 'lon', 'parking_type', 'quarter_price_m2', 'Region']]
data = data.reset_index(drop=True)
data['ID'] = data.index

# Проверка на дублирующиеся значения в столбце ID
if data['ID'].duplicated().any():
    print("Внимание: найдены дублирующиеся значения в столбце 'ID'.")

# Преобразование макрорегиона
data['RegionMacro'] = data['Region'].apply(region_macro)

analog_dist = 5.0

ap = []
ac = []
r = []

required_columns = ['Y+Q', 'propertyClass.name', 'wallMaterial.name', 'lat', 'lon', 'parking_type', 'quarter_price_m2', 'RegionMacro']

for idx in tqdm(data.index):
    target_row = data.iloc[[idx]]
    
    # Проверка наличия всех необходимых столбцов и их значений
    missing_columns = [col for col in required_columns if col not in target_row.columns or pd.isna(target_row.at[idx, col])]
    if missing_columns:
        print(f"Отсутствующие или некорректные столбцы для индекса {idx}: {missing_columns}")
        ap.append(None)
        ac.append(None)
        r.append(None)
        continue
    
    # Проверка форматов значений в столбцах
    try:
        for col in ['lat', 'lon']:
            target_row[col] = target_row[col].astype(float)
    except ValueError as e:
        print(f"Некорректные значения в столбце для индекса {idx}: {e}")
        ap.append(None)
        ac.append(None)
        r.append(None)
        continue

    try:
        print(f"Обработка индекса {idx}: {target_row[['Y+Q', 'propertyClass.name', 'wallMaterial.name', 'lat', 'lon', 'parking_type', 'RegionMacro']].to_dict(orient='records')}")
        price2, analog_count2, readiness2 = get_analog_price(target_row, data, max_dist=analog_dist)
        ap.append(price2)
        ac.append(analog_count2)
        r.append(readiness2)
    except Exception as e:
        print(f"Ошибка при обработке индекса {idx}: {e}")
        ap.append(None)
        ac.append(None)
        r.append(None)

# Восстановление исходного индекса и удаление временного столбца 'ID'
data.index = data['ID'].values.copy()
data.drop('ID', axis=1, inplace=True)

# Добавление рассчитанных значений в DataFrame
data['AnalogPrice'] = ap
data['AnalogCount'] = ac
data['Readiness'] = r

data.head()
