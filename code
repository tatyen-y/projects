def get_regional_price(self, target_row, data):
        try:
            idx = target_row.index[0]
            target_region = target_row.at[idx, 'Region']
            target_id = target_row.at[idx, 'ID']
            target_object_id = target_row.at[idx, 'objectId']
            target_date = target_row.at[idx, 'Sales_date']

            # Фильтрация данных: оставляем только записи из того же региона, даты меньше текущей и исключаем текущий объект
            regional_filter = (data['Region'] == target_region) & (data['Sales_date'] <= target_date) & (data['ID'] != target_id) & (data['objectId'] != target_object_id)
            regional_data = data[regional_filter].copy()

            # если не найдены аналоги
            if regional_data.shape[0] == 0:
                return -1, -1

            # Корректировка цен по времени
            regional_data['quarter_diff'] = regional_data['Sales_date'].apply(lambda x: self.calculate_quarter_diff(target_date, x))
            regional_data['price_corrected'] = regional_data['price'] * (1.02 ** regional_data['quarter_diff'])

            # Корректировка по типу стен
            wall_material = target_row.at[idx, 'wallMaterial.name']
            if wall_material in ['Монолитный', 'Кирпичный', 'Монолитно-кирпичный']:
                regional_data.loc[~regional_data['wallMaterial.name'].isin(['Монолитный', 'Кирпичный', 'Монолитно-кирпичный']), 'price_corrected'] *= 1.1
            else:
                regional_data.loc[regional_data['wallMaterial.name'].isin(['Монолитный', 'Кирпичный', 'Монолитно-кирпичный']), 'price_corrected'] /= 1.1

            # Корректировка по классу недвижимости
            property_class = target_row.at[idx, 'propertyClass.name']
            if property_class == 'Типовой':
                regional_data['price_corrected'] *= 1.1
            else:
                regional_data['price_corrected'] /= 1.1

            # Корректировка по виду парковки
            parking_type = target_row.at[idx, 'parking_type']
            if parking_type in ['наземная', 'многоуровневая наземная']:
                regional_data.loc[regional_data['parking_type'] == 'подземная', 'price_corrected'] *= 1.15
            elif parking_type == 'подземная':
                regional_data.loc[regional_data['parking_type'] == 'наземная', 'price_corrected'] /= 1.15
                regional_data.loc[regional_data['parking_type'] == 'многоуровневая наземная', 'price_corrected'] /= 1.15

            # Корректировка по макрорегиону
            target_region_macro = target_row.at[idx, 'RegionMacro']
            if target_region_macro not in ['MOS', 'SPB']:
                if target_row.at[idx, 'propertyClass.name'] in ['Комфорт', 'Бизнес']:
                    regional_data.loc[regional_data['propertyClass.name'] == 'Типовой', 'price_corrected'] *= 1.1
                else:
                    regional_data.loc[regional_data['propertyClass.name'].isin(['Комфорт', 'Бизнес']), 'price_corrected'] /= 1.1

            price_mean = regional_data['price_corrected'].mean()
            readiness_mean = regional_data['Readiness'].mean()

            return price_mean, readiness_mean
        except Exception as e:
            print(f"Ошибка при обработке индекса {idx}: {e}")
            return None, None
