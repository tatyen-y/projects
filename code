# Удаление дубликатов по индексу и проверка данных
data = data.reset_index(drop=True)
data['ID'] = data.index

# Проверка на дублирующиеся значения в столбце ID
if data['ID'].duplicated().any():
    print("Внимание: найдены дублирующиеся значения в столбце 'ID'.")

# Применение функции к новому датасету
analog_dist = 5.0

ap = []
ac = []
r = []

required_columns = ['Y+Q', 'propertyClass.name', 'wallMaterial.name', 'lat', 'lon', 'parking_type', 'RegionMacro']

for idx in tqdm(data.index):
    target_row = data.iloc[[idx]]
    
    # Проверка наличия всех необходимых столбцов и их значений
    missing_columns = [col for col in required_columns if col not in target_row.columns or pd.isna(target_row.at[idx, col])]
    if missing_columns:
        print(f"Отсутствующие или некорректные столбцы для индекса {idx}: {missing_columns}")
        ap.append(None)
        ac.append(None)
        r.append(None)
        continue
    
    # Проверка форматов значений в столбцах
    try:
        for col in ['lat', 'lon']:
            target_row[col] = target_row[col].astype(float)
    except ValueError as e:
        print(f"Некорректные значения в столбце для индекса {idx}: {e}")
        ap.append(None)
        ac.append(None)
        r.append(None)
        continue

    try:
        price2, analog_count2, readiness2 = get_analog_price(target_row, data, max_dist=analog_dist)
        ap.append(price2)
        ac.append(analog_count2)
        r.append(readiness2)
    except Exception as e:
        print(f"Ошибка при обработке индекса {idx}: {e}")
        ap.append(None)
        ac.append(None)
        r.append(None)

# Восстановление исходного индекса и удаление временного столбца 'ID'
data.index = data['ID'].values.copy()
data.drop('ID', axis=1, inplace=True)

# Добавление рассчитанных значений в DataFrame
data['AnalogPrice'] = ap
data['AnalogCount'] = ac
data['Readiness'] = r

data.head()
