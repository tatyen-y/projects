def get_analog_price(target_row, data, max_dist=5):
    # Получение индекса текущего объекта
    idx = target_row.index[0]

    # Преобразование координат текущего объекта в радианы
    lat = target_row.at[idx, 'lat'] * np.pi / 180
    lon = target_row.at[idx, 'lon'] * np.pi / 180

    # Фильтрация данных: исключаем текущий объект из данных
    analog_filter = (data['ID'] != target_row.at[idx, 'ID'])
    analog_data = data[analog_filter].copy()
    
    # Преобразование координат аналогов в радианы
    analog_data['lat_rad'] = analog_data['lat'] * np.pi / 180
    analog_data['lon_rad'] = analog_data['lon'] * np.pi / 180
    analog_data['DISTANCE'] = np.arccos(np.sin(lat) * np.sin(analog_data['lat_rad']) +
                                        np.cos(lat) * np.cos(analog_data['lat_rad']) *
                                        np.cos(analog_data['lon_rad'] - lon)) * 6371

    # Фильтрация аналогов в пределах max_dist км
    analogs = analog_data[analog_data['DISTANCE'] <= max_dist].copy()
    
    if analogs.shape[0] == 0:
        return -1, 0, -1  # Если нет аналогов в радиусе

    # Корректировка по макрорегиону
    target_region_macro = target_row.at[idx, 'RegionMacro']
    if target_region_macro not in ['MOS', 'SPB']:
        if target_row.at[idx, 'propertyClass.name'] == 'Комфорт':
            analogs['quarter_price_m2'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
        else:
            analogs['quarter_price_m2'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))

    # Корректировка цен по времени
    analogs['price_corrected'] = analogs['quarter_price_m2'] * (1.02 ** (target_row.at[idx, 'Y+Q'] - analogs['Y+Q']))

    # Корректировка по типу стен
    walls = target_row.at[idx, 'wallMaterial.name']
    if walls in ['Монолит', 'Кирпич', 'Монолит-кирпич']:
        analogs['price_corrected'] *= (1 + 0.1 * (1 - analogs['wallMaterial.name'].isin(['Монолит', 'Кирпич', 'Монолит-кирпич'])))
    else:
        analogs['price_corrected'] /= (1 + 0.1 * analogs['wallMaterial.name'].isin(['Монолит', 'Кирпич', 'Монолит-кирпич']))
    
    # Корректировка по классу недвижимости
    property_class = target_row.at[idx, 'propertyClass.name']
    if property_class == 'Комфорт':
        analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
    elif property_class == 'Бизнес':
        analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
    else:
        analogs['price_corrected'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
    
    # Корректировка по виду парковки
    parking_type = target_row.at[idx, 'parking_type']
    if parking_type == 'наземная' or parking_type == 'многоуровневая наземная':
        analogs['price_corrected'] /= (1 + 0.15 * (analogs['parking_type'] == 'подземная'))

    # Группировка и расчет средних значений
    analogs = analogs.groupby('ID').mean()
    price_mean = analogs['price_corrected'].mean()
    analog_count = analogs.shape[0]
    readiness_mean = analogs['ReadinessCalc'].mean()
    
    return price_mean, analog_count, readiness_mean

# Применение функции к новому датасету
data = data.reset_index()
data.rename(columns={'index': 'ID'}, inplace=True)

analog_dist = [5.0]

ap = []
ac = []
r = []

for idx in tqdm(data.index):
    target_row = data.iloc[[idx]]
    price2, analog_count2, readiness2 = get_analog_price(target_row, data, max_dist=analog_dist)
    ap.append(price2)
    ac.append(analog_count2)
    r.append(readiness2)

data.index = data['ID'].values.copy()
data.drop('ID', axis=1, inplace=True)

data['AnalogPrice'] = ap
data['AnalogCount'] = ac
data['Readiness'] = r

data.head()
