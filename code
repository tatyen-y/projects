import numpy as np
import pandas as pd
from tqdm import tqdm

# Определение макрорегиона
def region_macro(region: str) -> str:
    if region in ('Г. Москва', 'Москва', 'Москва Город', 'Город Москва'):
        return 'MOS'
    elif region in ('Ленинградская Область', 'Ленинградская область'):
        return 'LEN'
    elif region in ('Московская Область', 'Московская область'):
        return 'OBL'
    elif region in ('Санкт-Петербург', 'Санкт-Петербург Город', 'Город Санкт-Петербург'):
        return 'SPB'
    elif region in ('Краснодарский Край', 'Краснодарский край'):
        return 'KRA'
    elif region in ('Амурская Область', 'Амурская область', 'Бурятия Республика', 'Забайкальский Край',
                    'Забайкальский Край', 'Приморский Край', 'Приморский край', 'Магаданская Область',
                    'Магаданская область', 'Камчатский Край', 'Камчатский край', 'Камчатка',
                    'Сахалинская область', 'Сахалинская Область', 'Сахалин', 'Хабаровский Край',
                    'Хабаровский край', 'Чукотский автономный округ', 'Чукотский АО', 'Чукотка',
                    'Саха /Якутия/ Республика', 'Якутия', 'Саха', 'Саха Республика', 'Саха республика'):
        return 'FAR'
    else:
        return 'RUS'

def get_analog_price(obs, data, max_dist=5):
    idx = obs.index[0]

    lat = obs.at[idx, 'lat'] * np.pi / 180
    lon = obs.at[idx, 'lon'] * np.pi / 180

    # Фильтрация данных
    analog_filter = (data['ID'] != obs.at[idx, 'ID'])
    analog_data = data[analog_filter].copy()
    analog_data['lat_rad'] = analog_data['lat'] * np.pi / 180
    analog_data['lon_rad'] = analog_data['lon'] * np.pi / 180
    analog_data['DISTANCE'] = np.arccos(np.sin(lat) * np.sin(analog_data['lat_rad']) +
                                        np.cos(lat) * np.cos(analog_data['lat_rad']) *
                                        np.cos(analog_data['lon_rad'] - lon)) * 6371

    analogs = analog_data[analog_data['DISTANCE'] <= max_dist].copy()
    
    if analogs.shape[0] == 0:
        return -1, 0, -1  # Если нет аналогов в радиусе

    # Корректировка цен по времени
    analogs['price_corrected'] = analogs['quarter_price_m2'] * (1.02 ** (obs.at[idx, 'Y+Q'] - analogs['Y+Q']))

    # Корректировка по типу стен
    walls = obs.at[idx, 'wallMaterial.name']
    if walls in ['Монолит', 'Кирпич', 'Монолит-кирпич']:
        analogs['price_corrected'] *= (1 + 0.1 * (1 - analogs['wallMaterial.name'].isin(['Монолит', 'Кирпич', 'Монолит-кирпич'])))
    else:
        analogs['price_corrected'] /= (1 + 0.1 * analogs['wallMaterial.name'].isin(['Монолит', 'Кирпич', 'Монолит-кирпич']))
    
    # Корректировка по классу недвижимости
    property_class = obs.at[idx, 'propertyClass.name']
    if property_class == 'Комфорт':
        analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
    elif property_class == 'Бизнес':
        analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
    else:
        analogs['price_corrected'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))
    
    # Корректировка по виду парковки
    parking_type = obs.at[idx, 'parking_type']
    if parking_type == 'наземная' or parking_type == 'многоуровневая наземная':
        analogs['price_corrected'] /= (1 + 0.15 * (analogs['parking_type'] == 'подземная'))

    # Корректировка по макрорегиону
    obs_region_macro = region_macro(obs.at[idx, 'Region'])
    analogs['RegionMacro'] = analogs['Region'].apply(region_macro)
    if obs_region_macro not in ['MOS', 'SPB']:
        if obs.at[idx, 'propertyClass.name'] == 'Комфорт':
            analogs['price_corrected'] *= (1 + 0.1 * (analogs['propertyClass.name'] == 'Типовой'))
        else:
            analogs['price_corrected'] /= (1 + 0.1 * (analogs['propertyClass.name'] == 'Комфорт'))

    # Группировка и расчет средних значений
    analogs = analogs.groupby('ID').mean()
    price_mean = analogs['price_corrected'].mean()
    analog_count = analogs.shape[0]
    readiness_mean = analogs['ReadinessCalc'].mean()
    
    return price_mean, analog_count, readiness_mean

# Применение функции к новому датасету
data = data.reset_index()
data.rename(columns={'index': 'ID'}, inplace=True)

analog_dist = [5.0]

ap = []
ac = []
r = []

for idx in tqdm(data.index):
    obs = data.iloc[[idx]]
    price2, analog_count2, readiness2 = get_analog_price(obs, data, max_dist=analog_dist)
    ap.append(price2)
    ac.append(analog_count2)
    r.append(readiness2)

data.index = data['ID'].values.copy()
data.drop('ID', axis=1, inplace=True)

data['AnalogPrice'] = ap
data['AnalogCount'] = ac
data['Readiness'] = r

data.head()

